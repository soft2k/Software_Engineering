# Тема 9. Концепции и принципы ООП
Отчет по Теме #9 выполнил(а):
- Поляков Матвей Андреевич
- ИВТ-22-2

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |
| Задание 6 | - | - |
| Задание 7 | - | - |
| Задание 8 | - | - |
| Задание 9 | - | - |
| Задание 10 | - | - |


знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию init (), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.

```python
    class Ivan:
    
        __slots__ = ['name']
    
    
        def __init__(self, name):
            if name == "Иван":
                self.name = f"Да, я {name}"
            else:
                self.name = f"Я не {name}, а Иван"
    
    person1 = Ivan("Алексей")
    person2 = Ivan("Иван")
    print(person1.name)
    print(person2.name))
```
### Результат.
![image](https://github.com/user-attachments/assets/470f70eb-aa4b-4925-bc98-a58178cef2a4)

## Выводы
Код создает класс Ivan, который при инициализации объекта проверяет, является ли переданное имя "Иван", и в зависимости от этого устанавливает соответствующее сообщение в атрибуте name, после чего демонстрирует работу класса на двух примерах

## Лабораторная работа №2
### Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.

```python
    class IceCream:
        def __init__(self, ingredient=None):
            if isinstance(ingredient, str):
                self.ingredient = ingredient
            else:
                self.ingredient = None
    
    
        def composition(self):
            if self.ingredient is not None:
                print(f"Мороженое с {self.ingredient}")
            else:
                print('Обычное мороженое')
    
    icecream = IceCream()
    icecream.composition()
    icecream = IceCream('шоколадом')
    icecream.composition()
```
### Результат.
![image](https://github.com/user-attachments/assets/034ca6f8-318f-42f5-9cca-d8a1b09afc63)

## Выводы
Код создает класс IceCream для создания объектов мороженого, который при инициализации может принимать ингредиент в виде строки, а метод composition выводит информацию о том, обычное это мороженое или с добавленным ингредиентом.

## Лабораторная работа №3
### Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают.

```python
class MyClass:

    def __init__(self, value):
        self.__value = value

    def set_value(self, value):
        self.__value = value

    def get_value(self):
        return self.__value

    def del_value(self):
        del self.__value

    value = property(get_value,set_value,del_value,"Свойство value")


obj = MyClass(42)
print(obj.get_value())
```
### Результат.
![image](https://github.com/user-attachments/assets/c17ca1a9-6183-4a29-a48c-34a603005a62)

## Выводы
Код создает класс MyClass с приватным атрибутом __value и использует декоратор property для создания свойства value, которое позволяет получать, устанавливать и удалять значение этого атрибута через специальные методы.



## Лабораторная работа №4
### Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.

```python
class Mammal:
    className = 'Mammal'



class Dog(Mammal):
    species = 'canine'
    sound = 'wow'

class Cat(Mammal):
    species = 'feline'
    sound = 'meow'

dog = Dog()
print(f"{dog.className}, {dog.sound}")
```
### Результат.
![image](https://github.com/user-attachments/assets/23503d07-0bac-4315-b88a-0315494faccd)

## Выводы
Код демонстрирует наследование классов, где базовый класс Mammal наследуется классами Dog и Cat, каждый из которых имеет свои уникальные атрибуты species и sound, а затем выводится информация о созданном объекте класса Dog.

## Лабораторная работа №5
На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются.
Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.

```python
class Russian:
    @staticmethod
    def greeting():
        print('Привет')


class English:
    @staticmethod
    def greeting():
        print('Hello')
    

def greet(language):
    language.greeting()


ivan = Russian()
greet(ivan)

```
### Результат.
![image](https://github.com/user-attachments/assets/d97b67d1-f768-434b-a4b0-7521c2a8a4e2)

## Выводы
Код демонстрирует пример использования статических методов и переменных в Python для реализации приветствий на разных языках.


## Самостоятельная работа №1
Садовник и помидоры.  
Классовая структура:  
Есть Помидор со следующими характеристиками:  
• Индекс  
• Стадия созревания (стадии: отсутствует, цветение, зеленый, красный)  
Помидор может:  
• Расти (переходить на следующую стадию созревания)  
• Предоставлять информацию о своей зрелости      
Есть Куст с помидорами, который:  
• Содержит список томатов, которые на нем растут 
А также может:  
• Расти вместе с томатами  
• Предоставлять информацию о зрелости всех томатов  
• Предоставлять урожай  
И также есть Садовник, который имеет:  
• Имя  
• Растение, за которым он ухаживает 
Он может:  
• Ухаживать за растением  
• Собирать с него урожай

Задание: 
Тест:
1) Вызовите справку по садоводству 

```python
Gardener.knowledge_base()
```
### Результат.
![image](https://github.com/user-attachments/assets/0c67b60e-6018-4b51-8fbe-f096465448e2)

## Выводы
Из класса Gardener выводится справка по садоводству.

## Самостоятельная работа №2
Садовник и помидоры.  
Классовая структура:  
Есть Помидор со следующими характеристиками:  
• Индекс  
• Стадия созревания (стадии: отсутствует, цветение, зеленый, красный)  
Помидор может:  
• Расти (переходить на следующую стадию созревания)  
• Предоставлять информацию о своей зрелости      
Есть Куст с помидорами, который:  
• Содержит список томатов, которые на нем растут 
А также может:  
• Расти вместе с томатами  
• Предоставлять информацию о зрелости всех томатов  
• Предоставлять урожай  
И также есть Садовник, который имеет:  
• Имя  
• Растение, за которым он ухаживает 
Он может:  
• Ухаживать за растением  
• Собирать с него урожай

Задание:
Тест:
2) Создайте объекты классов TomatoBush и Gardener 

```python
bush = TomatoBush(5)
gardener = Gardener("Дмитрий", bush)
```
### Результат.
![image](https://github.com/user-attachments/assets/63c108e8-6c25-40e8-a592-fb50b8b87e89)

## Выводы
Создаем куст с 5 помидорами и садовника Дмитрия.

## Самостоятельная работа №3
Садовник и помидоры.  
Классовая структура:  
Есть Помидор со следующими характеристиками:  
• Индекс  
• Стадия созревания (стадии: отсутствует, цветение, зеленый, красный)  
Помидор может:  
• Расти (переходить на следующую стадию созревания)  
• Предоставлять информацию о своей зрелости      
Есть Куст с помидорами, который:  
• Содержит список томатов, которые на нем растут 
А также может:  
• Расти вместе с томатами  
• Предоставлять информацию о зрелости всех томатов  
• Предоставлять урожай  
И также есть Садовник, который имеет:  
• Имя  
• Растение, за которым он ухаживает 
Он может:  
• Ухаживать за растением  
• Собирать с него урожай

Задание:
Тест:
3) Используя объект класса Gardener, поухаживайте за кустом с помидорами 

```python
gardener.work()
```
### Результат.
![image](https://github.com/user-attachments/assets/daf99dd9-4622-4b94-bece-4eb931138869)

## Выводы
Вызываем функцию def work(self).

## Самостоятельная работа №4
Садовник и помидоры.  
Классовая структура:  
Есть Помидор со следующими характеристиками:  
• Индекс  
• Стадия созревания (стадии: отсутствует, цветение, зеленый, красный)  
Помидор может:  
• Расти (переходить на следующую стадию созревания)  
• Предоставлять информацию о своей зрелости      
Есть Куст с помидорами, который:  
• Содержит список томатов, которые на нем растут 
А также может:  
• Расти вместе с томатами  
• Предоставлять информацию о зрелости всех томатов  
• Предоставлять урожай  
И также есть Садовник, который имеет:  
• Имя  
• Растение, за которым он ухаживает 
Он может:  
• Ухаживать за растением  
• Собирать с него урожай

Задание:
Тест:
4) Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними 

```python
gardener.harvest()
for _ in range(3):
    gardener.work()
gardener.harvest()
```
### Результат.
![image](https://github.com/user-attachments/assets/69f915bd-0060-41f2-af78-42a4a8560d6f)

## Выводы
Пробуем собрать урожай, вызывая функцию def harvest(self). Если помидоры еще не созрели, запустится цикл, который вызывает функцию gardener.work(). После снова пробуем собрать урожай.

## Самостоятельная работа №5
Садовник и помидоры.  
Классовая структура:  
Есть Помидор со следующими характеристиками:  
• Индекс  
• Стадия созревания (стадии: отсутствует, цветение, зеленый, красный)  
Помидор может:  
• Расти (переходить на следующую стадию созревания)  
• Предоставлять информацию о своей зрелости      
Есть Куст с помидорами, который:  
• Содержит список томатов, которые на нем растут 
А также может:  
• Расти вместе с томатами  
• Предоставлять информацию о зрелости всех томатов  
• Предоставлять урожай  
И также есть Садовник, который имеет:  
• Имя  
• Растение, за которым он ухаживает 
Он может:  
• Ухаживать за растением  
• Собирать с него урожай

Задание:
Тест:  
5) Соберите урожай

```python
for tomato in bush.tomatoes:
    tomato.grow()
gardener.harvest()
```
### Результат.
![image](https://github.com/user-attachments/assets/f5d2dfbe-1217-411b-99f6-5ad4a1e1faa7)

## Выводы
Запускаем функцию tomato.grow(), которая переводит помидоры на соедующую стадию роста и после gardener.harvest(), чтобы собрать урожай.

## Самостоятельная работа №6
Садовник и помидоры.  
Классовая структура:  
Есть Помидор со следующими характеристиками:  
• Индекс  
• Стадия созревания (стадии: отсутствует, цветение, зеленый, красный)  
Помидор может:  
• Расти (переходить на следующую стадию созревания)  
• Предоставлять информацию о своей зрелости      
Есть Куст с помидорами, который:  
• Содержит список томатов, которые на нем растут 
А также может:  
• Расти вместе с томатами  
• Предоставлять информацию о зрелости всех томатов  
• Предоставлять урожай  
И также есть Садовник, который имеет:  
• Имя  
• Растение, за которым он ухаживает 
Он может:  
• Ухаживать за растением  
• Собирать с него урожай

Полный код программы + листинг кода:

```python
class Tomato:
    # Статическое свойство, которое описывает стадии созревания
    states = ["отсутствует", "цветение", "зеленый", "красный"]

    def __init__(self, index):
        self._index = index  # Динамическое свойство, индекс помидора (передается параметром)
        self._state = Tomato.states[0]  # Динамическое свойство, стадия созревания (инициализируется первой стадией)

    def grow(self):
        """Переход на следующую стадию созревания, если это возможно."""
        current_index = Tomato.states.index(self._state)
        if current_index < len(Tomato.states) - 1:
            self._state = Tomato.states[current_index + 1]

    def is_ripe(self):
        """Проверяет, созрел ли помидор."""
        return self._state == "красный"

class TomatoBush:
    def __init__(self, quantity):
        """Инициализация куста с заданным количеством помидоров."""
        self.tomatoes = [Tomato(i) for i in range(quantity)]  # Создание списка помидоров

    def grow_all(self):
        """Перевод всех помидоров на следующий этап созревания."""
        for tomato in self.tomatoes:
            tomato.grow()

    def all_are_ripe(self):
        """Проверяет, все ли помидоры созрели."""
        return all(tomato.is_ripe() for tomato in self.tomatoes)

    def give_away_all(self):
        """Очищает список помидоров после сбора урожая."""
        self.tomatoes.clear()

class Gardener:
    def __init__(self, name, plant):
        self.name = name  # Публичное свойство, имя садовника (передается параметром)
        self._plant = plant  # Приватное свойство, куст помидоров (принимает объект класса TomatoBush)

    def work(self):
        """Садовник ухаживает за растением, заставляя его расти."""
        self._plant.grow_all()

    def harvest(self):
        """Сбор урожая, если все плоды созрели."""
        if self._plant.all_are_ripe():
            print(f"{self.name} собрал урожай!")
            self._plant.give_away_all()
        else:
            print("Внимание! Не все помидоры созрели.")

    @staticmethod
    def knowledge_base():
        """Выводит справку по садоводству."""
        print("Справка по садоводству:")
        print("1. Поливайте растения регулярно.")
        print("2. Убедитесь, что свет падает на растения.")
        print("3. Удаляйте поврежденные плоды.")

# Тесты
Gardener.knowledge_base()  # Вызов справки по садоводству

bush = TomatoBush(5)  # Создание куста с 5 помидорами
gardener = Gardener("Дмитрий", bush)  # Создание садовника

# Ухаживаем за кустом
gardener.work()

# Попытка собрать урожай, когда томаты еще не дозрели
gardener.harvest()  # Вывод: Внимание! Не все помидоры созрели.

# Продолжаем ухаживать за растениями
for _ in range(3):  # Пусть пройдет несколько этапов роста
    gardener.work()

# Проверяем ещё раз
gardener.harvest()  # Вывод: Внимание! Не все помидоры созрели.

# Даем время для созревания
for tomato in bush.tomatoes:
    tomato.grow()
    
# Проверяем снова и собираем урожай
gardener.harvest()  # Вывод: Дмитрий собрал урожай!

```
### Результат.
![image](https://github.com/user-attachments/assets/613b6565-9c8b-4f9a-bdf3-5e94f950e4fc)

## Выводы
Класс Tomato:
- states: Статическое свойство, описывающее стадии созревания помидоров (отсутствует, цветение, зеленый, красный).
- init: Конструктор класса, задающий индекс помидора и начальную стадию созревания.
- grow(): Метод для перехода помидора на следующую стадию созревания. Проверяет текущее состояние и обновляет его.
- isripe()**: Метод для проверки, созрел ли помидор (если на стадии "красный").

Класс TomatoBush:
- init: Конструктор, который инициализирует куст помидоров с заданным количеством экземпляров класса Tomato.
- growall(): Метод, который заставляет все помидоры в кусте расти.
- allareripe(): Метод, проверяющий, все ли помидоры созрели (возвращает True или False).
- giveawayall(): Метод для полного удаления списка помидоров после сбора урожая.

Класс Gardener:
- init: Конструктор, принимающий имя садовника и растение (куст помидоров). Имя является публичным свойством, а растение - приватным.
- work(): Метод, позволяющий садовнику ухаживать за растением, вызывая его метод growall().
- harvest(): Метод, проверяющий возможность сбора урожая. Если все помидоры созрели, урожай собирается, иначе выводится предупреждение.
- knowledgebase(): Статический метод, печатающий советы по уходу за растениями.

Тесты:
- Демонстрация использования класса Gardener для ухода за кустом помидоров и сбора урожая.
- Проверка сбора урожая до созревания и после созревания с соответствующими выводами.

## Общие выводы по теме
Общие выводы по теме "Концепции и принципы ООП":

1. Объекты и классы:
   - Основная концепция ООП заключается в создании объектов на основе классов. Класс определяет структуру и поведение объектов, а объект является конкретным экземпляром этого класса.

2. Инкапсуляция:
   - Инкапсуляция (скрытие данных) позволяет ограничить доступ к внутренним состояниям объекта, предоставляя публичные методы для взаимодействия. Это помогает защищать данные от несанкционированного доступа и изменений, уменьшая вероятность ошибок.

3. Наследование:
   - Наследование позволяет создавать новые классы на основе существующих, наследуя их свойства и методы. Это способствует повторному использованию кода и облегчает его сопровождение. Наследующие классы могут добавлять или изменять поведение базового класса.

4. Полиморфизм:
   - Полиморфизм позволяет использования объектов разного типа через общий интерфейс. Это достигается за счет переопределения методов в дочерних классах, позволяя объектам вести себя по-разному, несмотря на единый интерфейс.

5. Абстракция:
   - Абстракция позволяет скрыть сложность системы, выделяя только наиболее важные особенности. Это достигается через создание абстрактных классов и интерфейсов, которые устанавливают контракт, что конкретные классы должны реализовать.

6. Композиция:
   - Композиция — это метод построения сложных объектов путём объединения нескольких простых объектов. Это альтернатива наследованию и позволяет создавать более гибкие и переиспользуемые компоненты.

7. Модульность:
    - ООП способствует модульности, позволяя разбивать код на самостоятельные компоненты (классы и модули), что облегчает разработку, тестирование и документацию.
